'RGBA_CRT's Librarys
#include "RGBADef.sbp"
/*  Todo : 
		HTTP系をクラスに
*/

Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
    TranslateMessage( msg )
    DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd As HWND) As Long
	Dim buf As BytePtr
	buf=calloc(GetWindowTextLength(hWnd)+5)
	GetWindowText(hWnd,buf,GetWindowTextLength(hWnd)+1)
	Dim i As Long,mode As Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			endif
		endif
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) As Long
	free(buf)
EndFunction

'エラーメッセージ表示
Function ErrMes(hOwner As HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction

'EXEC 終了コード取得
Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) As Long
	Dim si As STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		'CreateProcess Error
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	endif

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
Endfunction

Sub ChangeEndianDW(ByRef in As DWord)
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
EndSub

Function Str2Dw(Data As BytePtr) As DWORD
	memcpy(VarPtr(Str2Dw),Data,4)
endfunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte
	memcpy(Str,VarPtr(Data),4)
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump As Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）(バグあり)
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP As Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				Endif
				j--
				k--
			Wend
		Endif
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	'SP=j-InStrByteRev(Src,&H0A,j,&H0D)
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
'	Print Chr$(Src[j-SP])+"["+Hex$(Src[j-SP])+"]"
'	Print Chr$(Src[j-SP+1])+"["+Hex$(Src[j-SP+1])+"]"
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
/*	Line=calloc(EP+SP)
	memcpy(Line,Src+j-SP,EP+SP)
	Line[EP+SP]=0
	ListText2.AddStr(Line)
	SerchTextLine=j+EP*/
EndFunction

Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i As DWORD,si As Dword, sLen As Long
	'Dim tmp1 As Byte,tmp2 As Byte
	'sLen=lstrlen(Serch)
	Do
		if Data[i]=Serch then
			InStrByte=i	
			'debug
			ExitDo
		'	i++
		endif
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		endif
		i++
	Loop
endfunction

'APIを使った高速バージョンのダブルクォーテーション抜き
Function DelDQ(Text As BytePtr) As BytePtr
	Dim tmp[MAX_PATH] As Byte
	lstrcpy(tmp,Text)
	PathRemoveBlanks(tmp)
	PathUnquoteSpaces(tmp)

	Dim txlen As DWord
	txlen=lstrlen(tmp)
	DelDQ=calloc(txlen+2)
	memcpy(DelDQ,tmp,txlen+1)
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath As BytePtr) As Byte
	Dim hFile As HANDLE
	hFile=CreateFile(FilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
EndFunction

Function win_strcmpi(str1 As BytePtr,str2 As BytePtr,Length As DWord) As BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strcmpi=TRUE
	Else
		win_strcmpi=FALSE
	endif
EndFunction

Function win_strcmp(str1 As BytePtr,str2 As BytePtr,Length As DWord) As BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strcmp=TRUE
	Else
		win_strcmp=FALSE
	endif
EndFunction



'------------------------------
'		Network library
'------------------------------

'URLのパーセントエンコードを解除
Function URLDecode(pFrom As BytePtr) As BytePtr
   	Dim i = 0 As DWord
	Dim ASCII As Byte
	URLDecode=calloc(MAX_PATH+5)

   Do 
		if pFrom[i]=&H25 Then '% then
			ASCII=Hex2Dec(Chr$(pFrom[i+1])+Chr$(pFrom[i+2])) As Byte
			lstrcat(URLDecode , Chr$(ASCII))
			i=i+2
		Else
			lstrcat(URLDecode , Chr$(pFrom[i]))
		Endif
		i++			
		if pFrom[i] = 0 Then ExitDo
   Loop
End Function

Function GetHttpStatusText(HttpStatusNo As Long)
	Dim STATUS As BytePtr

	'出典：http://www.tohoho-web.com/ex/http.htm
	Select Case HttpStatusNo
		Case 100 : STATUS="[Continue] 処理を継続しています。続きのリクエストを送信してください。"
		Case 101 : STATUS="[Switching Protocols Upgrade] ヘッダで指定したプロトコルに変更して再要求してください。"
		Case 200 : STATUS="[OK] 成功しました！"
		Case 201 : STATUS="[Created Location] ヘッダで指定した場所に新しいコンテンツが作成されました。"
		Case 202 : STATUS="[Accepted] 要求は受理されました。ただし処理は完了していません。"
		Case 203 : STATUS="[Non-Authoritative Information] 応答ヘッダはオリジナルサーバーが返したものとは異なりますが、処理は成功です。"
		Case 204 : STATUS="[No Content] コンテンツはありませんが、処理は成功しました。"
		Case 205 : STATUS="[Reset Content] 要求を受理したので、現在のコンテンツ（画面）を破棄してください。"
		Case 206 : STATUS="[Partial Content] コンテンツを一部のみ返却します。"
		Case 300 : STATUS="[Multiple Choices] コンテンツ入手方法について複数の選択肢があります。"
		Case 301 : STATUS="[Moved Permanently Location ] ヘッダで指定された別の場所に移動しました。"
		Case 302 : STATUS="[Found	Location] ヘッダで指定された別の場所に見つかりました。そちらを見てください。"
		Case 303 : STATUS="[See Other Location] ヘッダで指定された他の場所を見てください。"
		Case 304 : STATUS="[Not Modified] 更新されていません。If-Modified-Since ヘッダを用いた場合に返却されます。"
		Case 305 : STATUS="[Use Proxy] Location ヘッダで指定したプロキシを使用してください。"
		Case 306 : STATUS="[Unused] 未使用のステータスが帰ってきました。きっと未来のサーバー。"
		Case 307 : STATUS="[Temporary Redirect] 別の場所に一時的に移動しています。"
		Case 400 : STATUS="[Bad Request] 要求が不正です。 > 大体こっち側のバグ"
		Case 401 : STATUS="[Unauthorized] 認証されてません。"
		Case 402 : STATUS="[Payment Required] 支払いが必要です。"
		Case 403 : STATUS="[Forbidden] アクセスが認められていません。"
		Case 404 : STATUS="[404 Not Found] ファイルが見つかりません。"
		Case 405 : STATUS="[Method Not Allowed] 指定したメソッドはサポートされていません。"
		Case 406 : STATUS="[Not Acceptable] 許可されていません。"
		Case 407 : STATUS="[Proxy Authentication Required] リクエストがタイムアウトしました。"
		Case 408 : STATUS="[Request Timeout] リクエストがタイムアウトしました。"
		Case 409 : STATUS="[Conflict] リクエストがコンフリクト（衝突・矛盾）しました。"
		Case 410 : STATUS="[Gone] 要求されたコンテンツは無くなってしまいました"
		Case 411 : STATUS="[Length Required] Content-Length ヘッダを付加して要求してください。"
		Case 412 : STATUS="[Precondition Failed] If-... ヘッダで指定された条件に合致しませんでした。"
		Case 413 : STATUS="[Request Entity Too Large]	要求されたエンティティが大きすぎます。"
		Case 414 : STATUS="[Request-URI Too Long] 要求された URI が長すぎます。"
		Case 415 : STATUS="[Unsupported Media Type] サポートされていないメディアタイプです。"
		Case 416 : STATUS="[Requested Range Not Satisfiable] 要求されたレンジが不正です。"
		Case 417 : STATUS="[Expectation Failed	Expect] ヘッダで指定された拡張要求は失敗しました。"
		Case 500 : STATUS="[Internal Server Error]	サーバーで予期しないエラーが発生しました。"
		Case 501 : STATUS="[Not Implemented] 指定されたHTTPメゾッドは実装されていません。"
		Case 502 : STATUS="[Bad Gateway] ゲートウェイが不正です。"
		Case 503 : STATUS="[Service Unavailable] サービスは利用可能ではありません。"
		Case 504 : STATUS="[Gateway Timeout] ゲートウェイがタイムアウトしました。"
		Case 505 : STATUS="[HTTP Version Not Supported] このHTTPバージョンはサポートされていません。"
		Case -1 : GetHttpStatusText="[ERROR] このプログラム側でのエラーが発生しました。" : ExitSub
		Case Else : STATUS="[UNKNOW] 未知のステータス番号です。"
	EndSelect

	GetHttpStatusText=STATUS

End Function


'------------------------------
'		Console library
'------------------------------

Function GetConsoleCursorDw() As DWord
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(GetConsoleCursor),CmdPos.dwCursorPosition,sizeof(DWord))
EndFunction

SUb GetConsoleCursor(ByRef pos As COORD)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(pos),VarPtr(CmdPos.dwCursorPosition),sizeof(DWord))
EndSub

Sub ConsoleReturnLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X=0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleReturnChar(count As Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X-=count
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() As HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon(IconID As DWord)
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IconID As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Const PRINTF_BUFFER = 1024*10
Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	Dim Buf As BytePtr,ret As Long,Ptr[13] As DWord
	Buf=calloc(lstrlen(lpFormat)+PRINTF_BUFFER)
	if Buf=0 Then MessageBox(0,ex"RGBALib - Line 37\nメモリ確保に失敗しました。",0,0)
'	Ptr[0]=a:	Ptr[1]=b:	Ptr[2]=c:	Ptr[3]=d:	Ptr[4]=e:	Ptr[5]=f:	Ptr[6]=g:	Ptr[7]=h:	Ptr[8]=i:	Ptr[9]=j:	Ptr[10]=k:		Ptr[11]=l:		Ptr[12]=m:		Ptr[13]=n:	
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
'	Print MakeStr(Buf);
	PrintPtr(Buf,ret)
	free(Buf)	
EndSub

Sub PrintPtr(Text As BytePtr)(Length As Long)
	Dim a As Long
	if Length=0 then Length=lstrlen(Text)
	WriteFile(_System_hConsoleOut,Text,Length,VarPtr(Length),ByVal NULL)
'	WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL
Endsub

Sub StringArrayViewer(Data As *Byte)
	dim i As long
	dim L As long
	Dim Tx[2] As Byte
	dim TB As byte

	L=lstrlen(Data)

	Print "Base Adress : 0x"+Hex$(Data)
	Print "Bytes       : "+Str$(L)+"Byte"
	Print ex"\nText : ";

	For i = 0 to L-1
		if TB <> 0 then
			Print "["+Chr$(TB)+Chr$(Data[i])+"] ";
			TB=0
			i++
		Endif

		if Data[i]=0 then ExitFor

		if Data[i] >= 128 then
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),2)
			Print " [>] ";
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),1 Or 2 Or 4)
			TB=Data[i]
		else
			Print " ["+Chr$(Data[i])+"] ";
			TB=0
		endif
	Next i

	Print ex"\nData : ";

	For i = 0 to L-1
		wsprintf(Tx,"%02X",Data[i])
		Print "["+MakeStr(Tx)+"] ";
	Next i

	Print ex"\nN[i] : ";

	For i = 0 to L-1
		wsprintf(Tx,"%02d",i)
		Print "["+MakeStr(Tx)+"] ";
	Next i

	Print ex"\n"
Endsub

Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,ShowHeader As BOOL) As DWORD
	Dim Tmp[&H20] As Byte,i As Long,Adr As DWORD
	
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	if VAdr=0 Or ShowHeader=TRUE then Print " ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF "
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE  OR 4 OR 3 )
		wsprintf(Tmp,"%08X ",Adr+VAdr)
		Print MakeStr(Tmp);
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then
				wsprintf(Tmp,"-- ",0)
			Else 
				wsprintf(Tmp,"%02X ",Data[Adr+i])
			endif
			Print MakeStr(Tmp);
		Next i
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then Goto *EXIT_LOOP
			if Data[Adr+i]<&H20 then 
				Print ".";
			Else
				Print Chr$(Data[Adr+i]);
			Endif
		Next i
		i=0
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
		Print
	Loop
*EXIT_LOOP
'	Print
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
Endfunction


'------------------------------
'		Class library
'------------------------------

'コマンドライン分割クラス
Class CommandLine
private 
	cmdStr As BytePtr
	count As Long
	table As *BytePtr

	Sub Destroy()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text As BytePtr,txlen As Long,offset As Long) As Long
		'Print
		Dim i As Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLine()
		ParseCommandLine(GetCommandLine())
	EndSub

	Function GetCount() As Long
		GetCount=count
	EndFunction

	Function GetCmd(index As DWord) As BytePtr
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index As DWord) As String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As BytePtr) As Byte
		if lstrcmpi(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		endif
	Endfunction

	Function ParseCommandLine(text As BytePtr) As Long
		if cmdStr<>0 Then Destroy()
		'確保
		Dim txlen As Long
		txlen=lstrlen(text)
		cmdStr=calloc(txlen+2)
		memcpy(cmdStr,text,txlen+1)

		'スペースを数える
		count=0
		Dim i As Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				count++
			endif
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(BytePtr)*(count+1))
		Dim it As Long
		table[0]=cmdStr
		For i = 0 To txlen
			'ダブルクォーテーション
			if text[i]=Asc(ex"\q") then
				i+=SkipDQ(cmdStr,txlen,i+1)
			endif

			'スペースを見つけたら、0で埋めてテーブルに次の文字列の開始位置を記録
			if cmdStr[i]=Asc(" ") Then
				it++
				For i = i To txlen
			'		if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1):Print "!"

					if cmdStr[i]<>Asc(" ") Then
						table[it]=cmdStr+i
						i--
						ExitFor
					Endif
					cmdStr[i]=0
				Next i
			Endif
		Next i
		it++
		table[it]=0
		count=it-1
	EndFunction
End Class


'ファイルパス用クラス
Class FilePath
Private
	pathStr As StringClass
	pNull As DWord
Public
	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As BytePtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQ(path))
		pNull=pathStr.length()
	EndSub

	'フォルダを一階層下げるなどの用途がある
	Sub PushDir(SubDir As BytePtr)
		if pathStr.ptr[pNull-1]=Asc("\") Then
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Else
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Endif
	EndSub

	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=Asc("\") Then	ExitFor
			if pathStr.ptr[i]=Asc(":") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	Sub cat(text As BytePtr)
		pathStr.cat(text)
	EndSub

	Function isExist() As Long
		isExist=PathFileExists(pathStr.ptr)
	EndFunction

	Function isDir() As Long
		if PathIsDirectory(pathStr.ptr) Then 
			isDir=FALSE
		Else
			isDir=TRUE
		Endif
	EndFunction

	Function GetPathString() As String
		GetPathString=pathStr.getString()
	EndFunction

	Function GetPath() As BytePtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetFileName() As BytePtr
		GetFileName=PathFindFileName(pathStr.ptr)
	EndFunction

	Function GetFileExt() As BytePtr
		GetFileExt=PathFindExtension(pathStr.ptr)
	EndFunction

	Function GetFileDirString() As String
		Dim tmp As BytePtr
		pathStr.copyToNewPtr(tmp)
		PathRemoveFileSpec(tmp)
		GetFileDirString=MakeStr(tmp)
		free(tmp)
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		pNull=0
	EndSub

	Sub ~FilePath()
		Destroy()
	EndSub
End Class


'EasyIOのクラス版
Class File
Private
	hFile As HANDLE
	path As FilePath
Public
	Function openFile(Path As BytePtr,_Mode As DWORD) As Long
		Dim CreateMode As Dword
		If _Mode=GENERIC_READ then
			CreateMode=OPEN_EXISTING
		Elseif  _Mode=GENERIC_WRITE then
			CreateMode=CREATE_ALWAYS
	    Else
	    	CreateMode=OPEN_ALWAYS
		EndIf

		hFile=CreateFile(Path, _Mode, FILE_SHARE_READ, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
		If hFile=INVALID_HANDLE_VALUE then 
			openFile = FALSE
			hFile=0
		Else
			openFile = TRUE
		Endif
	EndFunction

	Function read(dest As BytePtr,size As DWord) As Long
	     Dim dwAB As BytePtr
	     read=ReadFile(hFile,dest,size,VarPtr(dwAB),ByVal NULL) As BytePtr
	     If read=TRUE And dwAB=0 then
	          read=-1 As BytePtr
	     ElseIf read=FALSE then
	          read=-2 As BytePtr
	     Else
	          read=dwAB
	     EndIf
	End Function

	Function write(source As BytePtr,size As DWord) As Long
		WriteFile(hFile,source,size,VarPtr(write),ByVal NULL)
	End Function

	Function getFilePtr() As DWord
		nowFilePointer=SetFilePointer(hFile,0,0,FILE_CURRENT)
	EndFunction

	Sub setFilePtr(fp As DWord)
		SetFilePointer(hFile,fp,0,FILE_BEGIN)
	End Sub

	Sub addFilePtr(fp As DWord)
		SetFilePointer(hFile,fp,0,FILE_CURRENT)
	End Sub

	Function length() As Long
		if hFile = 0 Then length=-1 : Exitfunction
		length=GetFileSize(hFile,NULL)
	EndFunction

	Function getHandle() As HANDLE
		getHandle=hFile
	EndFunction

	Function getPath() As BytePtr
		getPath=path.GetPath()
	EndFunction

	Sub close()
		CloseHandle(hFile)
		hFile=0
		path.Destroy()
	End Sub
End Class


'速度重視の文字列クラス
Const STRCLASS_SPF_BUFFER = 1024
Class StringClass
Private
	pNull As DWord
	size As DWord
Public
	ptr As BytePtr

	Function cat(text As BytePtr) As Long
		Dim txlen As DWord
		txlen=lstrlen(text)
		if pNull+txlen >= size Then allocStr(txlen+size)
		memcpy(ptr+pNull,text,txlen)
		pNull+=txlen
		ptr[pNull]=0
	EndFunction

	Function cpy(text As BytePtr) As Long
		Dim txlen As DWord
		txlen=lstrlen(text)
		if txlen > size Then allocStr(txlen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction

	Function length() As DWord
		length=pNull
	EndFunction

	Function cmp(text As BytePtr) As Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text As BytePtr) As Long
		cmp=lstrcmp(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen As DWord
		txlen=lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text As BytePtr)
		freeStr()
		ptr=text
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateChar(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 

	Sub allocStr(newSize As DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=malloc(size)
		Else
			ptr=realloc(ptr,size)
		Endif
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub saveMem()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Function getString() As String
		getString=MakeStr(ptr)
	EndFunction

	Sub ~StringClass()
		freeStr()
	EndSub

End Class


'------------------------------------------------------
'			たぶんもう使わない関数
'------------------------------------------------------
'#include <EasyIO.sbp>


'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) As BytePtr
	Dim i As DWORD,fDQ As Byte,SP=-1 As Long'-1でセット待ち
	dim dbg As Byte
	dim  Buf As BytePtr,bi As DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
			If SP=-1 then
				If Text[i]<>&H20 then
					SP=i
					dbg=1
				Else
					Continue
				EndIf
			EndIf

			If fDQ=0 then
				If Text[i]=&H20 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
					SP=-1
				ElseIf Text[i]=0 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
				elseIf Text[i]=&H22 then'Doubleクォーテート
					fDQ=Not(fDQ)
				Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
Endfunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text As BytePtr,Num As Byte) As DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
Endfunction

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

'NULL文字記憶型strcat
Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
     If Size = 0 then Size=lstrlen(Src)
     memcpy(To+Ptr,Src,Size)
	'(free(Src)
     Ptr += Size
endsub

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
